{"version":3,"sources":["../src/chrome/breakOnLoadHelper.ts"],"names":[],"mappings":"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","file":"breakOnLoadHelper.js","sourcesContent":["/*---------------------------------------------------------\r\n * Copyright (C) Microsoft Corporation. All rights reserved.\r\n *--------------------------------------------------------*/\r\n\r\nimport { logger } from 'vscode-debugadapter';\r\nimport { ISetBreakpointResult, BreakOnLoadStrategy } from '../debugAdapterInterfaces';\r\n\r\nimport { Protocol as Crdp } from 'devtools-protocol';\r\nimport { ChromeDebugAdapter } from './chromeDebugAdapter';\r\nimport * as ChromeUtils from './chromeUtils';\r\nimport * as assert from 'assert';\r\nimport { InternalSourceBreakpoint } from './internalSourceBreakpoint';\r\nimport { utils, Version } from '..';\r\n\r\nexport interface UrlRegexAndFileSet {\r\n    urlRegex: string;\r\n    fileSet: Set<string>;\r\n}\r\n\r\nexport class BreakOnLoadHelper {\r\n    private _doesDOMInstrumentationRecieveExtraEvent = false;\r\n\r\n    private _instrumentationBreakpointSet = false;\r\n\r\n    // Break on load: Store some mapping between the requested file names, the regex for the file, and the chrome breakpoint id to perform lookup operations efficiently\r\n    private _stopOnEntryBreakpointIdToRequestedFileName = new Map<string, UrlRegexAndFileSet>();\r\n    private _stopOnEntryRequestedFileNameToBreakpointId = new Map<string, string>();\r\n    private _stopOnEntryRegexToBreakpointId = new Map<string, string>();\r\n\r\n    private _chromeDebugAdapter: ChromeDebugAdapter;\r\n    private _breakOnLoadStrategy: BreakOnLoadStrategy;\r\n\r\n    public constructor(chromeDebugAdapter: ChromeDebugAdapter, breakOnLoadStrategy: BreakOnLoadStrategy) {\r\n        this.validateStrategy(breakOnLoadStrategy);\r\n        this._chromeDebugAdapter = chromeDebugAdapter;\r\n        this._breakOnLoadStrategy = breakOnLoadStrategy;\r\n    }\r\n\r\n    validateStrategy(breakOnLoadStrategy: BreakOnLoadStrategy): void {\r\n        if (breakOnLoadStrategy !== 'regex' && breakOnLoadStrategy !== 'instrument') {\r\n            throw new Error('Invalid breakOnLoadStrategy: ' + breakOnLoadStrategy);\r\n        }\r\n    }\r\n\r\n    public get stopOnEntryRequestedFileNameToBreakpointId(): Map<string, string> {\r\n        return this._stopOnEntryRequestedFileNameToBreakpointId;\r\n    }\r\n\r\n    public get stopOnEntryBreakpointIdToRequestedFileName(): Map<string, UrlRegexAndFileSet> {\r\n        return this._stopOnEntryBreakpointIdToRequestedFileName;\r\n    }\r\n\r\n    private get instrumentationBreakpointSet(): boolean {\r\n        return this._instrumentationBreakpointSet;\r\n    }\r\n\r\n    private getScriptUrlFromId(scriptId: string): string {\r\n        return utils.canonicalizeUrl(this._chromeDebugAdapter.scriptsById.get(scriptId).url);\r\n    }\r\n\r\n    public async setBrowserVersion(version: Version): Promise<void> {\r\n        // On version 69 Chrome stopped sending an extra event for DOM Instrumentation: See https://bugs.chromium.org/p/chromium/issues/detail?id=882909\r\n        // On Chrome 68 we were relying on that event to make Break on load work on breakpoints on the first line of a file. On Chrome 69 we need an alternative way to make it work.\r\n        this._doesDOMInstrumentationRecieveExtraEvent = !version.isAtLeastVersion(69, 0);\r\n    }\r\n\r\n    /**\r\n     * Handles the onpaused event.\r\n     * Checks if the event is caused by a stopOnEntry breakpoint of using the regex approach, or the paused event due to the Chrome's instrument approach\r\n     * Returns whether we should continue or not on this paused event\r\n     */\r\n    public async handleOnPaused(notification: Crdp.Debugger.PausedEvent): Promise<boolean> {\r\n        if (notification.hitBreakpoints && notification.hitBreakpoints.length) {\r\n            // If breakOnLoadStrategy is set to regex, we may have hit a stopOnEntry breakpoint we put.\r\n            // So we need to resolve all the pending breakpoints in this script and then decide to continue or not\r\n            if (this._breakOnLoadStrategy === 'regex') {\r\n                let shouldContinue = await this.handleStopOnEntryBreakpointAndContinue(notification);\r\n                return shouldContinue;\r\n            }\r\n        } else if (this.isInstrumentationPause(notification)) {\r\n            // This is fired when Chrome stops on the first line of a script when using the setInstrumentationBreakpoint API\r\n            const pausedScriptId = notification.callFrames[0].location.scriptId;\r\n\r\n            // Now we wait for all the pending breakpoints to be resolved and then continue\r\n            await this._chromeDebugAdapter.getBreakpointsResolvedDefer(pausedScriptId).promise;\r\n            logger.log('BreakOnLoadHelper: Finished waiting for breakpoints to get resolved.');\r\n            let shouldContinue = this._doesDOMInstrumentationRecieveExtraEvent || await this.handleStopOnEntryBreakpointAndContinue(notification);\r\n            return shouldContinue;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private isInstrumentationPause(notification: Crdp.Debugger.PausedEvent): boolean {\r\n        return (notification.reason === 'EventListener' && notification.data.eventName === 'instrumentation:scriptFirstStatement') ||\r\n            (notification.reason === 'ambiguous' && Array.isArray(notification.data.reasons) &&\r\n                notification.data.reasons.every(r => r.reason === 'EventListener' && r.auxData.eventName === 'instrumentation:scriptFirstStatement'));\r\n    }\r\n\r\n    /**\r\n     * Returns whether we should continue on hitting a stopOnEntry breakpoint\r\n     * Only used when using regex approach for break on load\r\n     */\r\n    private async shouldContinueOnStopOnEntryBreakpoint(pausedLocation: Crdp.Debugger.Location): Promise<boolean> {\r\n        // If the file has no unbound breakpoints or none of the resolved breakpoints are at (1,1), we should continue after hitting the stopOnEntry breakpoint\r\n        let shouldContinue = true;\r\n\r\n        // Important: For the logic that verifies if a user breakpoint is set in the paused location, we need to resolve pending breakpoints, and commit them, before\r\n        // using committedBreakpointsByUrl for our logic.\r\n        await this._chromeDebugAdapter.getBreakpointsResolvedDefer(pausedLocation.scriptId).promise;\r\n\r\n        const pausedScriptUrl = this.getScriptUrlFromId(pausedLocation.scriptId);\r\n        // Important: We need to get the committed breakpoints only after all the pending breakpoints for this file have been resolved. If not this logic won't work\r\n        const committedBps = this._chromeDebugAdapter.committedBreakpointsByUrl.get(pausedScriptUrl) || [];\r\n        const anyBreakpointsAtPausedLocation = committedBps.filter(bp =>\r\n            bp.actualLocation &&\r\n            bp.actualLocation.lineNumber === pausedLocation.lineNumber &&\r\n            bp.actualLocation.columnNumber === pausedLocation.columnNumber).length > 0;\r\n\r\n        // If there were any breakpoints at this location (Which generally should be (1,1)) we shouldn't continue\r\n        if (anyBreakpointsAtPausedLocation) {\r\n            // Here we need to store this information per file, but since we can safely assume that scriptParsed would immediately be followed by onPaused event\r\n            // for the breakonload files, this implementation should be fine\r\n            shouldContinue = false;\r\n        }\r\n\r\n        return shouldContinue;\r\n    }\r\n\r\n    /**\r\n     * Handles a script with a stop on entry breakpoint and returns whether we should continue or not on hitting that breakpoint\r\n     * Only used when using regex approach for break on load\r\n     */\r\n    private async handleStopOnEntryBreakpointAndContinue(notification: Crdp.Debugger.PausedEvent): Promise<boolean> {\r\n        const hitBreakpoints = notification.hitBreakpoints;\r\n        let allStopOnEntryBreakpoints = true;\r\n\r\n        const pausedScriptId = notification.callFrames[0].location.scriptId;\r\n        const pausedScriptUrl = this._chromeDebugAdapter.scriptsById.get(pausedScriptId).url;\r\n        const mappedUrl = await this._chromeDebugAdapter.pathTransformer.scriptParsed(pausedScriptUrl);\r\n\r\n        // If there is a breakpoint which is not a stopOnEntry breakpoint, we appear as if we hit that one\r\n        // This is particularly done for cases when we end up with a user breakpoint and a stopOnEntry breakpoint on the same line\r\n        for (let bp of hitBreakpoints) {\r\n            let regexAndFileNames = this._stopOnEntryBreakpointIdToRequestedFileName.get(bp);\r\n            if (!regexAndFileNames) {\r\n                notification.hitBreakpoints = [bp];\r\n                allStopOnEntryBreakpoints = false;\r\n            } else {\r\n                const normalizedMappedUrl = utils.canonicalizeUrl(mappedUrl);\r\n                if (regexAndFileNames.fileSet.has(normalizedMappedUrl)) {\r\n                    regexAndFileNames.fileSet.delete(normalizedMappedUrl);\r\n                    assert(this._stopOnEntryRequestedFileNameToBreakpointId.delete(normalizedMappedUrl), `Expected to delete break-on-load information associated with url: ${normalizedMappedUrl}`);\r\n\r\n                    if (regexAndFileNames.fileSet.size === 0) {\r\n                        logger.log(`Stop on entry breakpoint hit for last remaining file. Removing: ${bp} created for: ${normalizedMappedUrl}`);\r\n                        await this.removeBreakpointById(bp);\r\n                        assert(this._stopOnEntryRegexToBreakpointId.delete(regexAndFileNames.urlRegex), `Expected to delete break-on-load information associated with regexp: ${regexAndFileNames.urlRegex}`);\r\n                    } else {\r\n                        logger.log(`Stop on entry breakpoint hit but still has remaining files. Keeping: ${bp} that was hit for: ${normalizedMappedUrl} because it's still needed for: ${Array.from(regexAndFileNames.fileSet.entries()).join(', ')}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // If all the breakpoints on this point are stopOnEntry breakpoints\r\n        // This will be true in cases where it's a single breakpoint and it's a stopOnEntry breakpoint\r\n        // This can also be true when we have multiple breakpoints and all of them are stopOnEntry breakpoints, for example in cases like index.js and index.bin.js\r\n        // Suppose user puts breakpoints in both index.js and index.bin.js files, when the setBreakpoints function is called for index.js it will set a stopOnEntry\r\n        // breakpoint on index.* files which will also match index.bin.js. Now when setBreakpoints is called for index.bin.js it will again put a stopOnEntry breakpoint\r\n        // in itself. So when the file is actually loaded, we would have 2 stopOnEntry breakpoints */\r\n\r\n        if (allStopOnEntryBreakpoints) {\r\n            const pausedLocation = notification.callFrames[0].location;\r\n            let shouldContinue = await this.shouldContinueOnStopOnEntryBreakpoint(pausedLocation);\r\n            if (shouldContinue) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Adds a stopOnEntry breakpoint for the given script url\r\n     * Only used when using regex approach for break on load\r\n     */\r\n    private async addStopOnEntryBreakpoint(url: string): Promise<ISetBreakpointResult[]> {\r\n        let responsePs: ISetBreakpointResult[];\r\n        // Check if file already has a stop on entry breakpoint\r\n        if (!this._stopOnEntryRequestedFileNameToBreakpointId.has(url)) {\r\n\r\n            // Generate regex we need for the file\r\n            const normalizedUrl = utils.canonicalizeUrl(url);\r\n            const urlRegex = ChromeUtils.getUrlRegexForBreakOnLoad(normalizedUrl);\r\n\r\n            // Check if we already have a breakpoint for this regexp since two different files like script.ts and script.js may have the same regexp\r\n            let breakpointId: string;\r\n            breakpointId = this._stopOnEntryRegexToBreakpointId.get(urlRegex);\r\n\r\n            // If breakpointId is undefined it means the breakpoint doesn't exist yet so we add it\r\n            if (breakpointId === undefined) {\r\n                let result;\r\n                try {\r\n                    result = await this.setStopOnEntryBreakpoint(urlRegex);\r\n                } catch (e) {\r\n                    logger.log(`Exception occured while trying to set stop on entry breakpoint ${e.message}.`);\r\n                }\r\n                if (result) {\r\n                    breakpointId = result.breakpointId;\r\n                    this._stopOnEntryRegexToBreakpointId.set(urlRegex, breakpointId);\r\n                } else {\r\n                    logger.log(`BreakpointId was null when trying to set on urlregex ${urlRegex}. This normally happens if the breakpoint already exists.`);\r\n                }\r\n                responsePs = [result];\r\n            } else {\r\n                responsePs = [];\r\n            }\r\n\r\n            // Store the new breakpointId and the file name in the right mappings\r\n            this._stopOnEntryRequestedFileNameToBreakpointId.set(normalizedUrl, breakpointId);\r\n\r\n            let regexAndFileNames = this._stopOnEntryBreakpointIdToRequestedFileName.get(breakpointId);\r\n\r\n            // If there already exists an entry for the breakpoint Id, we add this file to the list of file mappings\r\n            if (regexAndFileNames !== undefined) {\r\n                regexAndFileNames.fileSet.add(normalizedUrl);\r\n            } else { // else create an entry for this breakpoint id\r\n                const fileSet = new Set<string>();\r\n                fileSet.add(normalizedUrl);\r\n                this._stopOnEntryBreakpointIdToRequestedFileName.set(breakpointId, { urlRegex, fileSet });\r\n            }\r\n        } else {\r\n            responsePs = [];\r\n        }\r\n        return Promise.all(responsePs);\r\n    }\r\n\r\n    /**\r\n     * Handles the AddBreakpoints request when break on load is active\r\n     * Takes the action based on the strategy\r\n     */\r\n    public async handleAddBreakpoints(url: string, breakpoints: InternalSourceBreakpoint[]): Promise<ISetBreakpointResult[]> {\r\n        // If the strategy is set to regex, we try to match the file where user put the breakpoint through a regex and tell Chrome to put a stop on entry breakpoint there\r\n        if (this._breakOnLoadStrategy === 'regex') {\r\n        await this.addStopOnEntryBreakpoint(url);\r\n        } else if (this._breakOnLoadStrategy === 'instrument') {\r\n            // Else if strategy is to use Chrome's experimental instrumentation API, we stop on all the scripts at the first statement before execution\r\n            if (!this.instrumentationBreakpointSet) {\r\n                await this.setInstrumentationBreakpoint();\r\n            }\r\n        }\r\n\r\n        // Temporary fix: We return an empty element for each breakpoint that was requested\r\n        return breakpoints.map(breakpoint => { return {}; });\r\n    }\r\n\r\n    /**\r\n     * Tells Chrome to set instrumentation breakpoint to stop on all the scripts before execution\r\n     * Only used when using instrument approach for break on load\r\n     */\r\n    private async setInstrumentationBreakpoint(): Promise<void> {\r\n        await this._chromeDebugAdapter.chrome.DOMDebugger.setInstrumentationBreakpoint({eventName: 'scriptFirstStatement'});\r\n        this._instrumentationBreakpointSet = true;\r\n    }\r\n\r\n    // Sets a breakpoint on (0,0) for the files matching the given regex\r\n    private async setStopOnEntryBreakpoint(urlRegex: string): Promise<Crdp.Debugger.SetBreakpointByUrlResponse> {\r\n        let result = await this._chromeDebugAdapter.chrome.Debugger.setBreakpointByUrl({ urlRegex, lineNumber: 0, columnNumber: 0 });\r\n        return result;\r\n    }\r\n\r\n    // Removes a breakpoint by it's chrome-crdp-id\r\n    private async removeBreakpointById(breakpointId: string): Promise<void> {\r\n        return await this._chromeDebugAdapter.chrome.Debugger.removeBreakpoint({breakpointId: breakpointId });\r\n    }\r\n\r\n    /**\r\n     * Checks if we need to call resolvePendingBPs on scriptParsed event\r\n     * If break on load is active and we are using the regex approach, only call the resolvePendingBreakpoint function for files where we do not\r\n     * set break on load breakpoints. For those files, it is called from onPaused function.\r\n     * For the default Chrome's API approach, we don't need to call resolvePendingBPs from inside scriptParsed\r\n     */\r\n    public shouldResolvePendingBPs(mappedUrl: string): boolean {\r\n        if (this._breakOnLoadStrategy === 'regex' && !this.stopOnEntryRequestedFileNameToBreakpointId.has(mappedUrl)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}"],"sourceRoot":"../.."}