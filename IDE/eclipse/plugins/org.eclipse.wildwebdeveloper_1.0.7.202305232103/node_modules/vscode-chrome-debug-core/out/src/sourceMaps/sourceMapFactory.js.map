{"version":3,"sources":["../src/sourceMaps/sourceMapFactory.ts"],"names":[],"mappings":"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","file":"sourceMapFactory.js","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as fs from 'fs';\nimport * as crypto from 'crypto';\nimport * as path from 'path';\nimport * as os from 'os';\nimport * as url from 'url';\n\nimport * as sourceMapUtils from './sourceMapUtils';\nimport * as utils from '../utils';\nimport { logger } from 'vscode-debugadapter';\nimport { SourceMap } from './sourceMap';\nimport { ISourceMapPathOverrides, IPathMapping } from '../debugAdapterInterfaces';\nimport { isInternalRemotePath } from '../remoteMapper';\n\nexport class SourceMapFactory {\n    constructor(\n        private _pathMapping?: IPathMapping,\n        private _sourceMapPathOverrides?: ISourceMapPathOverrides,\n        private _enableSourceMapCaching?: boolean) {\n    }\n\n    /**\n     * pathToGenerated - an absolute local path or a URL.\n     * mapPath - a path relative to pathToGenerated.\n     */\n    getMapForGeneratedPath(pathToGenerated: string, originalUrlToGenerated: string | undefined, mapPath: string, isVSClient = false): Promise<SourceMap> {\n        let msg = `SourceMaps.getMapForGeneratedPath: Finding SourceMap for ${pathToGenerated} by URI: ${mapPath}`;\n        if (this._pathMapping) {\n            msg += ` and webRoot/pathMapping: ${JSON.stringify(this._pathMapping)}`;\n        }\n\n        logger.log(msg);\n\n        // For an inlined sourcemap, mapPath is a data URI containing a blob of base64 encoded data, starting\n        // with a tag like \"data:application/json;charset:utf-8;base64,\". The data should start after the last comma.\n        let sourceMapContentsP: Promise<string>;\n        if (mapPath.indexOf('data:application/json') >= 0) {\n            // Sourcemap is inlined\n            logger.log(`SourceMaps.getMapForGeneratedPath: Using inlined sourcemap in ${pathToGenerated}`);\n            sourceMapContentsP = Promise.resolve(this.getInlineSourceMapContents(mapPath));\n        } else {\n            const accessPath = isInternalRemotePath(pathToGenerated) && originalUrlToGenerated ?\n                originalUrlToGenerated :\n                pathToGenerated;\n            sourceMapContentsP = this.getSourceMapContent(accessPath, mapPath);\n        }\n\n        return sourceMapContentsP.then(contents => {\n            if (contents) {\n                try {\n                    // Throws for invalid JSON\n                    return new SourceMap(pathToGenerated, contents, this._pathMapping, this._sourceMapPathOverrides, isVSClient);\n                } catch (e) {\n                    logger.error(`SourceMaps.getMapForGeneratedPath: exception while processing path: ${pathToGenerated}, sourcemap: ${mapPath}\\n${e.stack}`);\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        });\n    }\n\n    /**\n     * Parses sourcemap contents from inlined base64-encoded data\n     */\n    private getInlineSourceMapContents(sourceMapData: string): string {\n        const firstCommaPos = sourceMapData.indexOf(',');\n        if (firstCommaPos < 0) {\n            logger.log(`SourceMaps.getInlineSourceMapContents: Inline sourcemap is malformed. Starts with: ${sourceMapData.substr(0, 200)}`);\n            return null;\n        }\n        const header = sourceMapData.substr(0, firstCommaPos);\n        const data = sourceMapData.substr(firstCommaPos + 1);\n\n        try {\n            if (header.indexOf(';base64') !== -1) {\n                const buffer = Buffer.from(data, 'base64');\n                return buffer.toString();\n            } else {\n                // URI encoded.\n                return decodeURI(data);\n            }\n        } catch (e) {\n            logger.error(`SourceMaps.getInlineSourceMapContents: exception while processing data uri (${e.stack})`);\n        }\n\n        return null;\n    }\n\n    /**\n     * Resolves a sourcemap's path and loads the data\n     */\n    private getSourceMapContent(pathToGenerated: string, mapPath: string): Promise<string> {\n        mapPath = sourceMapUtils.resolveMapPath(pathToGenerated, mapPath, this._pathMapping);\n        if (!mapPath) {\n            return Promise.resolve(null);\n        }\n\n        return this.loadSourceMapContents(mapPath).then(contents => {\n            if (!contents) {\n                // Last ditch effort - just look for a .js.map next to the script\n                const mapPathNextToSource = pathToGenerated + '.map';\n                if (mapPathNextToSource !== mapPath) {\n                    return this.loadSourceMapContents(mapPathNextToSource);\n                }\n            }\n\n            return contents;\n        });\n    }\n\n    private loadSourceMapContents(mapPathOrURL: string): Promise<string> {\n        let contentsP: Promise<string>;\n        if (utils.isURL(mapPathOrURL) && !utils.isFileUrl(mapPathOrURL)) {\n            logger.log(`SourceMaps.loadSourceMapContents: Downloading sourcemap file from ${mapPathOrURL}`);\n            contentsP = this.downloadSourceMapContents(mapPathOrURL).catch(e => {\n                logger.log(`SourceMaps.loadSourceMapContents: Could not download sourcemap from ${mapPathOrURL}`);\n                return null;\n            });\n        } else {\n            mapPathOrURL = utils.canonicalizeUrl(mapPathOrURL);\n            contentsP = new Promise((resolve, reject) => {\n                logger.log(`SourceMaps.loadSourceMapContents: Reading local sourcemap file from ${mapPathOrURL}`);\n                fs.readFile(mapPathOrURL, (err, data) => {\n                    if (err) {\n                        logger.log(`SourceMaps.loadSourceMapContents: Could not read sourcemap file - ` + err.message);\n                        resolve(null);\n                    } else {\n                        resolve(data && data.toString());\n                    }\n                });\n            });\n        }\n\n        return contentsP;\n    }\n\n    private async downloadSourceMapContents(sourceMapUri: string): Promise<string> {\n        try {\n            return await this._downloadSourceMapContents(sourceMapUri);\n        } catch (e) {\n            if (url.parse(sourceMapUri).hostname === 'localhost') {\n                logger.log(`Sourcemaps.downloadSourceMapContents: downlading from 127.0.0.1 instead of localhost`);\n                return this._downloadSourceMapContents(sourceMapUri.replace('localhost', '127.0.0.1'));\n            }\n\n            throw e;\n        }\n    }\n\n    private async _downloadSourceMapContents(sourceMapUri: string): Promise<string> {\n        // use sha256 to ensure the hash value can be used in filenames\n        let cachedSourcemapPath: string;\n        if (this._enableSourceMapCaching) {\n            const hash = crypto.createHash('sha256').update(sourceMapUri).digest('hex');\n\n            const cachePath = path.join(os.tmpdir(), 'com.microsoft.VSCode', 'node-debug2', 'sm-cache');\n            cachedSourcemapPath = path.join(cachePath, hash);\n\n            const exists = utils.existsSync(cachedSourcemapPath);\n            if (exists) {\n                logger.log(`Sourcemaps.downloadSourceMapContents: Reading cached sourcemap file from ${cachedSourcemapPath}`);\n                return this.loadSourceMapContents(cachedSourcemapPath);\n            }\n        }\n\n        const responseText = await utils.getURL(sourceMapUri);\n        if (cachedSourcemapPath && this._enableSourceMapCaching) {\n            logger.log(`Sourcemaps.downloadSourceMapContents: Caching sourcemap file at ${cachedSourcemapPath}`);\n            await utils.writeFileP(cachedSourcemapPath, responseText);\n        }\n\n        return responseText;\n    }\n}\n"],"sourceRoot":"../.."}