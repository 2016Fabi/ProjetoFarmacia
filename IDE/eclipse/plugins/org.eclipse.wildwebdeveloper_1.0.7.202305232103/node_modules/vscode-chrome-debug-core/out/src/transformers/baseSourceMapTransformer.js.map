{"version":3,"sources":["../src/transformers/baseSourceMapTransformer.ts"],"names":[],"mappings":";AAAA;;4DAE4D;;;;;;;;;;AAE5D,6BAA6B;AAM7B,yDAAsD;AACtD,kCAAkC;AAClC,6DAA6C;AAE7C,kCAAkC;AAElC,kDAAuD;AACvD,MAAM,QAAQ,GAAG,GAAG,CAAC,iBAAiB,YAAE,CAAC;AAezC;;GAEG;AACH;IAiBI,YAAY,aAA8B;QAPhC,aAAQ,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;QAC/B,4BAAuB,GAAiB,OAAO,CAAC,OAAO,EAAE,CAAC;QAIxD,gBAAW,GAAG,KAAK,CAAC;QAG1B,IAAI,CAAC,gBAAgB,GAAG,aAAa,CAAC;IAC1C,CAAC;IAED,IAAW,UAAU;QACjB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;IAC5B,CAAC;IAED,IAAW,UAAU,CAAC,QAAiB;QACnC,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC;IAChC,CAAC;IAEM,MAAM,CAAC,IAAwB;QAClC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAEM,MAAM,CAAC,IAAwB;QAClC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAES,IAAI,CAAC,IAA6C;QACxD,EAAE,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;YAClB,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,sBAAsB,CAAC;YAC3D,IAAI,CAAC,WAAW,GAAG,IAAI,uBAAU,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,sBAAsB,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAC;YAC/G,IAAI,CAAC,+BAA+B,GAAG,IAAI,GAAG,EAAoC,CAAC;YACnF,IAAI,CAAC,sBAAsB,GAAG,IAAI,GAAG,EAAU,CAAC;YAChD,IAAI,CAAC,yBAAyB,GAAG,IAAI,GAAG,EAA4C,CAAC;YACrF,IAAI,CAAC,mCAAmC,GAAG,IAAI,GAAG,EAAoB,CAAC;QAC3E,CAAC;IACL,CAAC;IAEM,kBAAkB;QACrB,IAAI,CAAC,sBAAsB,GAAG,IAAI,GAAG,EAAU,CAAC;IACpD,CAAC;IAED;;;OAGG;IACI,cAAc,CAAC,IAAyB,EAAE,UAAkB,EAAE,GAAc;QAC/E,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YACpB,MAAM,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC;QACzB,CAAC;QAED,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;QAEjE,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC;YAC9B,4EAA4E;YAC5E,0BAA0B;YAC1B,MAAM,MAAM,GAAG,IAAI,CAAC,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC;YAC5E,EAAE,CAAC,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC;gBAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,UAAU,CAAC;YACzC,CAAC;QACL,CAAC;QAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;YACnB,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YAClC,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,gCAAgC,CAAC,QAAQ,CAAC,CAAC;YAC/E,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;gBACb,4BAAM,CAAC,GAAG,CAAC,4BAA4B,QAAQ,OAAO,UAAU,EAAE,CAAC,CAAC;gBACpE,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;gBAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,UAAU,CAAC;gBAE9B,iFAAiF;gBACjF,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;oBAC1B,MAAM,EAAE,IAAI,EAAE,MAAM,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC;oBAChC,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,QAAQ,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;oBACvE,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACT,4BAAM,CAAC,GAAG,CAAC,4BAA4B,QAAQ,IAAI,IAAI,GAAG,CAAC,IAAI,MAAM,GAAG,CAAC,OAAO,UAAU,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;wBACtI,EAAE,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;wBACtB,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;oBAC9B,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACJ,4BAAM,CAAC,GAAG,CAAC,4BAA4B,QAAQ,iBAAiB,IAAI,GAAG,CAAC,YAAY,CAAC,CAAC;wBACtF,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,2BAA2B;oBACnD,CAAC;gBACL,CAAC,CAAC,CAAC;gBAEH,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;gBAE/D,6DAA6D;gBAC7D,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBACN,IAAI,CAAC,mCAAmC,CAAC,GAAG,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;gBAChE,CAAC;gBAED,yGAAyG;gBACzG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;oBAC/D,EAAE,CAAC,CAAC,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC;wBAC1B,MAAM,CAAC;oBACX,CAAC;oBAED,MAAM,SAAS,GAAG,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBACjE,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;wBACZ,gCAAgC;wBAChC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;wBAEtD,8GAA8G;wBAC9G,qHAAqH;wBACrH,MAAM,mBAAmB,GAAG,IAAI,CAAC,mCAAmC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;wBACrF,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;4BACN,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC;wBAC1C,CAAC;oBACL,CAAC;gBACL,CAAC,CAAC,CAAC;YACP,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBACxC,wCAAwC;gBACxC,4BAAM,CAAC,GAAG,CAAC,gDAAgD,QAAQ,sBAAsB,CAAC,CAAC;YAC/F,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,kDAAkD;gBAClD,4BAAM,CAAC,GAAG,CAAC,qBAAqB,QAAQ,uEAAuE,CAAC,CAAC;YACrH,CAAC;QACL,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,iBAAiB;QACrB,CAAC;QAED,IAAI,CAAC,+BAA+B,CAAC,GAAG,CAAC,UAAU,EAAE;YACjD,WAAW;YACX,YAAY,EAAE,IAAI,CAAC,YAAY;YAC/B,aAAa,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI;SAClC,CAAC,CAAC;QAEH,MAAM,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE,CAAC;IACzB,CAAC;IAED;;OAEG;IACI,sBAAsB,CAAC,WAAuC,EAAE,YAAqB,EAAE,UAAkB;QAC5G,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,+BAA+B,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC3E,MAAM,IAAI,GAAG,IAAI,CAAC,+BAA+B,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YAClE,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC;gBACpB,yDAAyD;gBACzD,mFAAmF;gBACnF,EAAE,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC;oBACf,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;gBAC5E,CAAC;gBAED,WAAW,CAAC,OAAO,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE,EAAE;oBAC1B,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;oBACtF,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;wBACT,4BAAM,CAAC,GAAG,CAAC,4BAA4B,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,OAAO,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC;wBACpI,EAAE,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;wBACtB,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;oBAC9B,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACJ,4BAAM,CAAC,GAAG,CAAC,+BAA+B,IAAI,CAAC,aAAa,IAAI,EAAE,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC,MAAM,GAAG,CAAC,kCAAkC,CAAC,CAAC;wBAChI,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;4BACtB,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;4BACnC,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;wBAC3C,CAAC;oBACL,CAAC;oBAED,IAAI,CAAC,+BAA+B,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;gBAC5D,CAAC,CAAC,CAAC;YACP,CAAC;QACL,CAAC;QAED,MAAM,CAAC,WAAW,CAAC;IACvB,CAAC;IAED;;OAEG;IACU,kBAAkB,CAAC,QAAyC;;YACrE,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;gBACnB,MAAM,IAAI,CAAC,uBAAuB,CAAC;gBACnC,GAAG,CAAC,CAAC,IAAI,UAAU,IAAI,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC;oBAC1C,MAAM,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;gBAC7C,CAAC;YACL,CAAC;QACL,CAAC;KAAA;IAEY,iBAAiB,CAAC,cAAmD;;YAC9E,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;gBACpB,MAAM,CAAC;YACX,CAAC;YAED,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;gBACzB,MAAM,CAAC;YACX,CAAC;YAED,MAAM,IAAI,CAAC,uBAAuB,CAAC;YAEnC,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,EAAE,cAAc,CAAC,IAAI,EAAE,cAAc,CAAC,MAAM,CAAC,CAAC;YACtH,EAAE,CAAC,CAAC,MAAM,IAAI,CAAC,mCAAoB,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrF,2DAA2D;gBAC3D,cAAc,CAAC,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC;gBAC3C,cAAc,CAAC,MAAM,CAAC,eAAe,GAAG,SAAS,CAAC;gBAClD,cAAc,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC1D,cAAc,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;gBAClC,cAAc,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;gBACtC,cAAc,CAAC,cAAc,GAAG,IAAI,CAAC;gBACrC,MAAM,CAAC;YACX,CAAC;YACD,MAAM,aAAa,GAAG,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;YACjF,EAAE,CAAC,CAAC,MAAM,IAAI,aAAa,CAAC,CAAC,CAAC;gBAC1B,uEAAuE;gBACvE,8DAA8D;gBAC9D,cAAc,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC1D,cAAc,CAAC,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC;gBAC3C,cAAc,CAAC,MAAM,CAAC,eAAe,GAAG,IAAI,CAAC,gBAAgB,CAAC,+BAA+B,CAAC,MAAM,CAAC,MAAM,EAAE,aAAa,CAAC,CAAC;gBAC5H,cAAc,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ,CAAC,CAA2B,EAAE,IAA2C,CAAC,CAAC;gBAClH,cAAc,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;gBAClC,cAAc,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;gBACtC,cAAc,CAAC,cAAc,GAAG,IAAI,CAAC;gBACrC,MAAM,CAAC;YACX,CAAC;YACD,EAAE,CAAC,CAAC,KAAK,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBAC/C,6FAA6F;gBAC7F,cAAc,CAAC,MAAM,CAAC,eAAe,GAAG,SAAS,CAAC;gBAClD,cAAc,CAAC,MAAM,CAAC,MAAM,GAAG,SAAS,CAAC;gBACzC,MAAM,CAAC;YACX,CAAC;QACL,CAAC;KAAA;IAEY,YAAY,CAAC,eAAuB,EAAE,sBAA0C,EAAE,YAAoB;;YAC/G,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;gBACnB,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC,CAAC;gBAErE,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC;oBAAC,MAAM,CAAC,IAAI,CAAC;gBAE/B,6DAA6D;gBAC7D,MAAM,oBAAoB,GAAG,IAAI,CAAC,WAAW,CAAC,mBAAmB,CAAC,eAAe,EAAE,sBAAsB,EAAE,YAAY,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC3I,IAAI,CAAC,uBAAuB,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,uBAAuB,EAAE,oBAAoB,CAAC,CAAC,CAAC;gBACjG,MAAM,oBAAoB,CAAC;gBAE3B,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,eAAe,CAAC,CAAC;gBACnE,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;oBACV,4BAAM,CAAC,GAAG,CAAC,4BAA4B,eAAe,4CAA4C,IAAI,CAAC,SAAS,CAAC,OAAO,CAAE,EAAE,CAAC,CAAC;gBAClI,CAAC;gBAED,MAAM,CAAC,OAAO,CAAC;YACnB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACJ,MAAM,CAAC,IAAI,CAAC;YAChB,CAAC;QACL,CAAC;KAAA;IAEM,kBAAkB,CAAC,EAA4B,EAAE,UAAkB;QACtE,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YACnB,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,UAAU,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;YAC9E,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACT,wEAAwE;gBACxE,EAAE,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;gBACtB,EAAE,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC;YAC9B,CAAC;QACL,CAAC;IACL,CAAC;IAEM,cAAc,CAAC,eAAuB,EAAE,cAAmC;QAC9E,EAAE,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;YACnB,cAAc,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,eAAe,EAAE,KAAK,CAAC,CAAC,CAAC;QAC3F,CAAC;IACL,CAAC;IAEO,iBAAiB,CAAC,eAAuB,EAAE,KAA0B;QACzE,2IAA2I;QAC3I,EAAE,CAAC,CAAC,OAAO,KAAK,CAAC,IAAI,KAAK,QAAQ,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,IAAI,KAAK,CAAC,OAAO,GAAG,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;YACnH,MAAM,CAAC;QACX,CAAC;QAED,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,eAAe,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;QAC5F,IAAI,wBAAwB,GAAG,KAAK,CAAC;QAErC,yGAAyG;QACzG,6CAA6C;QAC7C,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACf,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,eAAe,EAAE,KAAK,CAAC,IAAI,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;YAC5F,wBAAwB,GAAG,IAAI,CAAC;QACpC,CAAC;QAED,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;YACd,gDAAgD;YAChD,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,eAAe,EAAE,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;YAClG,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;gBACZ,KAAK,CAAC,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC;gBAC9B,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;oBAC3B,KAAK,CAAC,IAAI,EAAE,CAAC;gBACjB,CAAC;gBACD,KAAK,CAAC,MAAM,GAAG,WAAW,CAAC,MAAM,CAAC;gBAElC,KAAK,CAAC,OAAO,GAAG,SAAS,CAAC,IAAI,CAAC;gBAC/B,KAAK,CAAC,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC;YACvC,CAAC;QACL,CAAC;IACL,CAAC;IAEY,cAAc,CAAC,YAAoB,EAAE,IAAY,EAAE,MAAc;;YAC1E,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;gBAAC,MAAM,CAAC,IAAI,CAAC;YAEnC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC,YAAY,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QACvE,CAAC;KAAA;IAEY,aAAa,CAAC,eAAuB,EAAE,IAAY,EAAE,MAAc;;YAC5E,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;gBAAC,MAAM,CAAC,IAAI,CAAC;YAEnC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,eAAe,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC;QACzE,CAAC;KAAA;IAEY,gCAAgC,CAAC,YAAoB;;YAC9D,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;gBAAC,MAAM,CAAC,YAAY,CAAC;YAE3C,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;YAElB,wGAAwG;YACxG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,gCAAgC,CAAC,YAAY,CAAC;gBAClE,CAAC,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACnE,CAAC;KAAA;IAEY,UAAU,CAAC,eAAuB;;YAC3C,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;gBAAC,MAAM,CAAC,EAAE,CAAC;YAEjC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QACpE,CAAC;KAAA;IAEY,oBAAoB,CAAC,eAAuB;;YACrD,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC;gBAAC,MAAM,CAAC,EAAE,CAAC;YAEjC,MAAM,IAAI,CAAC,IAAI,EAAE,CAAC;YAClB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,oBAAoB,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;QACxE,CAAC;KAAA;IAEO,IAAI;QACR,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAC,CAAC;IACtE,CAAC;IAEO,eAAe,CAAC,UAAkB;QACtC,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC,CAAC;IAC3E,CAAC;IAEO,aAAa,CAAC,GAAW;QAC7B,MAAM,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC;IACtE,CAAC;CACJ;AA9VD,4DA8VC","file":"baseSourceMapTransformer.js","sourceRoot":"../..","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as path from 'path';\nimport { DebugProtocol } from 'vscode-debugprotocol';\n\nimport { ISetBreakpointsArgs, ILaunchRequestArgs, IAttachRequestArgs,\n    IInternalStackTraceResponseBody, IScopesResponseBody, IInternalStackFrame } from '../debugAdapterInterfaces';\nimport { MappedPosition, ISourcePathDetails } from '../sourceMaps/sourceMap';\nimport { SourceMaps } from '../sourceMaps/sourceMaps';\nimport * as utils from '../utils';\nimport { logger } from 'vscode-debugadapter';\n\nimport * as nls from 'vscode-nls';\nimport { ScriptContainer } from '../chrome/scripts';\nimport { isInternalRemotePath } from '../remoteMapper';\nconst localize = nls.loadMessageBundle();\n\ninterface ISavedSetBreakpointsArgs {\n    generatedPath: string;\n    authoredPath: string;\n    originalBPs: DebugProtocol.Breakpoint[];\n}\n\nexport interface ISourceLocation {\n    source: DebugProtocol.Source;\n    line: number;\n    column: number;\n    isSourceMapped?: boolean; // compat with stack frame\n}\n\n/**\n * If sourcemaps are enabled, converts from source files on the client side to runtime files on the target side\n */\nexport class BaseSourceMapTransformer {\n    protected _sourceMaps: SourceMaps;\n    protected _scriptContainer: ScriptContainer;\n    private _enableSourceMapCaching: boolean;\n\n    private _requestSeqToSetBreakpointsArgs: Map<number, ISavedSetBreakpointsArgs>;\n    private _allRuntimeScriptPaths: Set<string>;\n    private _authoredPathsToMappedBPs: Map<string, DebugProtocol.SourceBreakpoint[]>;\n    private _authoredPathsToClientBreakpointIds: Map<string, number[]>;\n\n    protected _preLoad = Promise.resolve();\n    private _processingNewSourceMap: Promise<any> = Promise.resolve();\n\n    public caseSensitivePaths: boolean;\n\n    protected _isVSClient = false;\n\n    constructor(sourceHandles: ScriptContainer) {\n        this._scriptContainer = sourceHandles;\n    }\n\n    public get sourceMaps(): SourceMaps {\n        return this._sourceMaps;\n    }\n\n    public set isVSClient(newValue: boolean) {\n        this._isVSClient = newValue;\n    }\n\n    public launch(args: ILaunchRequestArgs): void {\n        this.init(args);\n    }\n\n    public attach(args: IAttachRequestArgs): void {\n        this.init(args);\n    }\n\n    protected init(args: ILaunchRequestArgs | IAttachRequestArgs): void {\n        if (args.sourceMaps) {\n            this._enableSourceMapCaching = args.enableSourceMapCaching;\n            this._sourceMaps = new SourceMaps(args.pathMapping, args.sourceMapPathOverrides, this._enableSourceMapCaching);\n            this._requestSeqToSetBreakpointsArgs = new Map<number, ISavedSetBreakpointsArgs>();\n            this._allRuntimeScriptPaths = new Set<string>();\n            this._authoredPathsToMappedBPs = new Map<string, DebugProtocol.SourceBreakpoint[]>();\n            this._authoredPathsToClientBreakpointIds = new Map<string, number[]>();\n        }\n    }\n\n    public clearTargetContext(): void {\n        this._allRuntimeScriptPaths = new Set<string>();\n    }\n\n    /**\n     * Apply sourcemapping to the setBreakpoints request path/lines.\n     * Returns true if completed successfully, and setBreakpoint should continue.\n     */\n    public setBreakpoints(args: ISetBreakpointsArgs, requestSeq: number, ids?: number[]): { args: ISetBreakpointsArgs, ids: number[] } {\n        if (!this._sourceMaps) {\n            return { args, ids };\n        }\n\n        const originalBPs = JSON.parse(JSON.stringify(args.breakpoints));\n\n        if (args.source.sourceReference) {\n            // If the source contents were inlined, then args.source has no path, but we\n            // stored it in the handle\n            const handle = this._scriptContainer.getSource(args.source.sourceReference);\n            if (handle && handle.mappedPath) {\n                args.source.path = handle.mappedPath;\n            }\n        }\n\n        if (args.source.path) {\n            const argsPath = args.source.path;\n            const mappedPath = this._sourceMaps.getGeneratedPathFromAuthoredPath(argsPath);\n            if (mappedPath) {\n                logger.log(`SourceMaps.setBP: Mapped ${argsPath} to ${mappedPath}`);\n                args.authoredPath = argsPath;\n                args.source.path = mappedPath;\n\n                // DebugProtocol doesn't send cols yet, but they need to be added from sourcemaps\n                args.breakpoints.forEach(bp => {\n                    const { line, column = 0 } = bp;\n                    const mapped = this._sourceMaps.mapToGenerated(argsPath, line, column);\n                    if (mapped) {\n                        logger.log(`SourceMaps.setBP: Mapped ${argsPath}:${line + 1}:${column + 1} to ${mappedPath}:${mapped.line + 1}:${mapped.column + 1}`);\n                        bp.line = mapped.line;\n                        bp.column = mapped.column;\n                    } else {\n                        logger.log(`SourceMaps.setBP: Mapped ${argsPath} but not line ${line + 1}, column 1`);\n                        bp.column = column; // take 0 default if needed\n                    }\n                });\n\n                this._authoredPathsToMappedBPs.set(argsPath, args.breakpoints);\n\n                // Store the client breakpoint Ids for the mapped BPs as well\n                if (ids) {\n                    this._authoredPathsToClientBreakpointIds.set(argsPath, ids);\n                }\n\n                // Include BPs from other files that map to the same file. Ensure the current file's breakpoints go first\n                this._sourceMaps.allMappedSources(mappedPath).forEach(sourcePath => {\n                    if (sourcePath === argsPath) {\n                        return;\n                    }\n\n                    const sourceBPs = this._authoredPathsToMappedBPs.get(sourcePath);\n                    if (sourceBPs) {\n                        // Don't modify the cached array\n                        args.breakpoints = args.breakpoints.concat(sourceBPs);\n\n                        // We need to assign the client IDs we generated for the mapped breakpoints becuase the runtime IDs may change\n                        // So make sure we concat the client ids to the ids array so that they get mapped to the respective breakpoints later\n                        const clientBreakpointIds = this._authoredPathsToClientBreakpointIds.get(sourcePath);\n                        if (ids) {\n                            ids = ids.concat(clientBreakpointIds);\n                        }\n                    }\n                });\n            } else if (this.isRuntimeScript(argsPath)) {\n                // It's a generated file which is loaded\n                logger.log(`SourceMaps.setBP: SourceMaps are enabled but ${argsPath} is a runtime script`);\n            } else {\n                // Source (or generated) file which is not loaded.\n                logger.log(`SourceMaps.setBP: ${argsPath} can't be resolved to a loaded script. It may just not be loaded yet.`);\n            }\n        } else {\n            // No source.path\n        }\n\n        this._requestSeqToSetBreakpointsArgs.set(requestSeq, {\n            originalBPs,\n            authoredPath: args.authoredPath,\n            generatedPath: args.source.path\n        });\n\n        return { args, ids };\n    }\n\n    /**\n     * Apply sourcemapping back to authored files from the response\n     */\n    public setBreakpointsResponse(breakpoints: DebugProtocol.Breakpoint[], shouldFilter: boolean, requestSeq: number): DebugProtocol.Breakpoint[] {\n        if (this._sourceMaps && this._requestSeqToSetBreakpointsArgs.has(requestSeq)) {\n            const args = this._requestSeqToSetBreakpointsArgs.get(requestSeq);\n            if (args.authoredPath) {\n                // authoredPath is set, so the file was mapped to source.\n                // Remove breakpoints from files that map to the same file, and map back to source.\n                if (shouldFilter) {\n                    breakpoints = breakpoints.filter((_, i) => i < args.originalBPs.length);\n                }\n\n                breakpoints.forEach((bp, i) => {\n                    const mapped = this._sourceMaps.mapToAuthored(args.generatedPath, bp.line, bp.column);\n                    if (mapped) {\n                        logger.log(`SourceMaps.setBP: Mapped ${args.generatedPath}:${bp.line + 1}:${bp.column + 1} to ${mapped.source}:${mapped.line + 1}`);\n                        bp.line = mapped.line;\n                        bp.column = mapped.column;\n                    } else {\n                        logger.log(`SourceMaps.setBP: Can't map ${args.generatedPath}:${bp.line + 1}:${bp.column + 1}, keeping original line numbers.`);\n                        if (args.originalBPs[i]) {\n                            bp.line = args.originalBPs[i].line;\n                            bp.column = args.originalBPs[i].column;\n                        }\n                    }\n\n                    this._requestSeqToSetBreakpointsArgs.delete(requestSeq);\n                });\n            }\n        }\n\n        return breakpoints;\n    }\n\n    /**\n     * Apply sourcemapping to the stacktrace response\n     */\n    public async stackTraceResponse(response: IInternalStackTraceResponseBody): Promise<void> {\n        if (this._sourceMaps) {\n            await this._processingNewSourceMap;\n            for (let stackFrame of response.stackFrames) {\n                await this.fixSourceLocation(stackFrame);\n            }\n        }\n    }\n\n    public async fixSourceLocation(sourceLocation: ISourceLocation|IInternalStackFrame): Promise<void> {\n        if (!this._sourceMaps) {\n            return;\n        }\n\n        if (!sourceLocation.source) {\n            return;\n        }\n\n        await this._processingNewSourceMap;\n\n        const mapped = this._sourceMaps.mapToAuthored(sourceLocation.source.path, sourceLocation.line, sourceLocation.column);\n        if (mapped && (isInternalRemotePath(mapped.source) || utils.existsSync(mapped.source))) {\n            // Script was mapped to a valid local path or internal path\n            sourceLocation.source.path = mapped.source;\n            sourceLocation.source.sourceReference = undefined;\n            sourceLocation.source.name = path.basename(mapped.source);\n            sourceLocation.line = mapped.line;\n            sourceLocation.column = mapped.column;\n            sourceLocation.isSourceMapped = true;\n            return;\n        }\n        const inlinedSource = mapped && this._sourceMaps.sourceContentFor(mapped.source);\n        if (mapped && inlinedSource) {\n            // Clear the path and set the sourceReference - the client will ask for\n            // the source later and it will be returned from the sourcemap\n            sourceLocation.source.name = path.basename(mapped.source);\n            sourceLocation.source.path = mapped.source;\n            sourceLocation.source.sourceReference = this._scriptContainer.getSourceReferenceForScriptPath(mapped.source, inlinedSource);\n            sourceLocation.source.origin = localize('origin.inlined.source.map', 'read-only inlined content from source map');\n            sourceLocation.line = mapped.line;\n            sourceLocation.column = mapped.column;\n            sourceLocation.isSourceMapped = true;\n            return;\n        }\n        if (utils.existsSync(sourceLocation.source.path)) {\n            // Script could not be mapped, but does exist on disk. Keep it and clear the sourceReference.\n            sourceLocation.source.sourceReference = undefined;\n            sourceLocation.source.origin = undefined;\n            return;\n        }\n    }\n\n    public async scriptParsed(pathToGenerated: string, originalUrlToGenerated: string | undefined, sourceMapURL: string): Promise<string[]> {\n        if (this._sourceMaps) {\n            this._allRuntimeScriptPaths.add(this.fixPathCasing(pathToGenerated));\n\n            if (!sourceMapURL) return null;\n\n            // Load the sourcemap for this new script and log its sources\n            const processNewSourceMapP = this._sourceMaps.processNewSourceMap(pathToGenerated, originalUrlToGenerated, sourceMapURL, this._isVSClient);\n            this._processingNewSourceMap = Promise.all([this._processingNewSourceMap, processNewSourceMapP]);\n            await processNewSourceMapP;\n\n            const sources = this._sourceMaps.allMappedSources(pathToGenerated);\n            if (sources) {\n                logger.log(`SourceMaps.scriptParsed: ${pathToGenerated} was just loaded and has mapped sources: ${JSON.stringify(sources) }`);\n            }\n\n            return sources;\n        } else {\n            return null;\n        }\n    }\n\n    public breakpointResolved(bp: DebugProtocol.Breakpoint, scriptPath: string): void {\n        if (this._sourceMaps) {\n            const mapped = this._sourceMaps.mapToAuthored(scriptPath, bp.line, bp.column);\n            if (mapped) {\n                // No need to send back the path, the bp can only move within its script\n                bp.line = mapped.line;\n                bp.column = mapped.column;\n            }\n        }\n    }\n\n    public scopesResponse(pathToGenerated: string, scopesResponse: IScopesResponseBody): void {\n        if (this._sourceMaps) {\n            scopesResponse.scopes.forEach(scope => this.mapScopeLocations(pathToGenerated, scope));\n        }\n    }\n\n    private mapScopeLocations(pathToGenerated: string, scope: DebugProtocol.Scope): void {\n        // The runtime can return invalid scope locations. Just skip those scopes. https://github.com/Microsoft/vscode-chrome-debug-core/issues/333\n        if (typeof scope.line !== 'number' || scope.line < 0 || scope.endLine < 0 || scope.column < 0 || scope.endColumn < 0) {\n            return;\n        }\n\n        let mappedStart = this._sourceMaps.mapToAuthored(pathToGenerated, scope.line, scope.column);\n        let shiftedScopeStartForward = false;\n\n        // If the scope is an async function, then the function declaration line may be missing a source mapping.\n        // So if we failed, try to get the next line.\n        if (!mappedStart) {\n            mappedStart = this._sourceMaps.mapToAuthored(pathToGenerated, scope.line + 1, scope.column);\n            shiftedScopeStartForward = true;\n        }\n\n        if (mappedStart) {\n            // Only apply changes if both mappings are found\n            const mappedEnd = this._sourceMaps.mapToAuthored(pathToGenerated, scope.endLine, scope.endColumn);\n            if (mappedEnd) {\n                scope.line = mappedStart.line;\n                if (shiftedScopeStartForward) {\n                    scope.line--;\n                }\n                scope.column = mappedStart.column;\n\n                scope.endLine = mappedEnd.line;\n                scope.endColumn = mappedEnd.column;\n            }\n        }\n    }\n\n    public async mapToGenerated(authoredPath: string, line: number, column: number): Promise<MappedPosition> {\n        if (!this._sourceMaps) return null;\n\n        await this.wait();\n        return this._sourceMaps.mapToGenerated(authoredPath, line, column);\n    }\n\n    public async mapToAuthored(pathToGenerated: string, line: number, column: number): Promise<MappedPosition> {\n        if (!this._sourceMaps) return null;\n\n        await this.wait();\n        return this._sourceMaps.mapToAuthored(pathToGenerated, line, column);\n    }\n\n    public async getGeneratedPathFromAuthoredPath(authoredPath: string): Promise<string> {\n        if (!this._sourceMaps) return authoredPath;\n\n        await this.wait();\n\n        // Find the generated path, or check whether this script is actually a runtime path - if so, return that\n        return this._sourceMaps.getGeneratedPathFromAuthoredPath(authoredPath) ||\n            (this.isRuntimeScript(authoredPath) ? authoredPath : null);\n    }\n\n    public async allSources(pathToGenerated: string): Promise<string[]> {\n        if (!this._sourceMaps) return [];\n\n        await this.wait();\n        return this._sourceMaps.allMappedSources(pathToGenerated) || [];\n    }\n\n    public async allSourcePathDetails(pathToGenerated: string): Promise<ISourcePathDetails[]> {\n        if (!this._sourceMaps) return [];\n\n        await this.wait();\n        return this._sourceMaps.allSourcePathDetails(pathToGenerated) || [];\n    }\n\n    private wait(): Promise<any> {\n        return Promise.all([this._preLoad, this._processingNewSourceMap]);\n    }\n\n    private isRuntimeScript(scriptPath: string): boolean {\n        return this._allRuntimeScriptPaths.has(this.fixPathCasing(scriptPath));\n    }\n\n    private fixPathCasing(str: string): string {\n        return str && (this.caseSensitivePaths ? str : str.toLowerCase());\n    }\n}\n"]}