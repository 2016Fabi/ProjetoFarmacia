{"version":3,"sources":["../src/sourceMaps/sourceMapUtils.ts"],"names":[],"mappings":"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","file":"sourceMapUtils.js","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport * as path from 'path';\nimport * as url from 'url';\nimport { logger } from 'vscode-debugadapter';\n\nimport * as chromeUtils from '../chrome/chromeUtils';\nimport * as utils from '../utils';\nimport { ISourceMapPathOverrides, IPathMapping } from '../debugAdapterInterfaces';\n\n/**\n * Resolves a relative path in terms of another file\n */\nexport function resolveRelativeToFile(absPath: string, relPath: string): string {\n    return utils.properResolve(path.dirname(absPath), relPath);\n}\n\n/**\n * Determine an absolute path for the sourceRoot.\n */\nexport function getComputedSourceRoot(sourceRoot: string, generatedPath: string, pathMapping: IPathMapping = {}): string {\n    generatedPath = utils.fileUrlToPath(generatedPath);\n\n    let absSourceRoot: string;\n    if (sourceRoot) {\n        if (sourceRoot.startsWith('file:///')) {\n            // sourceRoot points to a local path like \"file:///c:/project/src\", make it an absolute path\n            absSourceRoot = utils.canonicalizeUrl(sourceRoot);\n        } else if (utils.isAbsolute(sourceRoot)) {\n            // sourceRoot is like \"/src\", should be like http://localhost/src, resolve to a local path using pathMaping.\n            // If path mappings do not apply (e.g. node), assume that sourceRoot is actually a local absolute path.\n            // Technically not valid but it's easy to end up with paths like this.\n            absSourceRoot = chromeUtils.applyPathMappingsToTargetUrlPath(sourceRoot, pathMapping) || sourceRoot;\n\n            // If no pathMapping (node), use sourceRoot as is.\n            // But we also should handle an absolute sourceRoot for chrome? Does CDT handle that? No it does not, it interprets it as \"localhost/full path here\"\n        } else if (path.isAbsolute(generatedPath)) {\n            // sourceRoot is like \"src\" or \"../src\", relative to the script\n            absSourceRoot = resolveRelativeToFile(generatedPath, sourceRoot);\n        } else {\n            // generatedPath is a URL so runtime script is not on disk, resolve the sourceRoot location on disk.\n            const generatedUrlPath = url.parse(generatedPath).pathname;\n            const mappedPath = chromeUtils.applyPathMappingsToTargetUrlPath(generatedUrlPath, pathMapping);\n            const mappedDirname = path.dirname(mappedPath);\n            absSourceRoot = utils.properJoin(mappedDirname, sourceRoot);\n        }\n\n        logger.log(`SourceMap: resolved sourceRoot ${sourceRoot} -> ${absSourceRoot}`);\n    } else if (path.isAbsolute(generatedPath)) {\n        absSourceRoot = path.dirname(generatedPath);\n        logger.log(`SourceMap: no sourceRoot specified, using script dirname: ${absSourceRoot}`);\n    } else {\n        // No sourceRoot and runtime script is not on disk, resolve the sourceRoot location on disk\n        const urlPathname = url.parse(generatedPath).pathname || '/placeholder.js';  // could be debugadapter://123, no other info.\n        const mappedPath = chromeUtils.applyPathMappingsToTargetUrlPath(urlPathname, pathMapping);\n        const scriptPathDirname = mappedPath ? path.dirname(mappedPath) : '';\n        absSourceRoot = scriptPathDirname;\n        logger.log(`SourceMap: no sourceRoot specified, using webRoot + script path dirname: ${absSourceRoot}`);\n    }\n\n    absSourceRoot = utils.stripTrailingSlash(absSourceRoot);\n    absSourceRoot = utils.fixDriveLetterAndSlashes(absSourceRoot);\n\n    return absSourceRoot;\n}\n\nlet aspNetFallbackCount = 0;\nexport function getAspNetFallbackCount(): number {\n    return aspNetFallbackCount;\n}\n\n/**\n * Applies a set of path pattern mappings to the given path. See tests for examples.\n * Returns something validated to be an absolute path.\n */\nexport function applySourceMapPathOverrides(sourcePath: string, sourceMapPathOverrides: ISourceMapPathOverrides, isVSClient = false): string {\n    const forwardSlashSourcePath = sourcePath.replace(/\\\\/g, '/');\n\n    // Sort the overrides by length, large to small\n    const sortedOverrideKeys = Object.keys(sourceMapPathOverrides)\n        .sort((a, b) => b.length - a.length);\n\n    // Iterate the key/vals, only apply the first one that matches.\n    for (let leftPattern of sortedOverrideKeys) {\n        const rightPattern = sourceMapPathOverrides[leftPattern];\n        const entryStr = `\"${leftPattern}\": \"${rightPattern}\"`;\n\n        const asterisks = leftPattern.match(/\\*/g) || [];\n        if (asterisks.length > 1) {\n            logger.log(`Warning: only one asterisk allowed in a sourceMapPathOverrides entry - ${entryStr}`);\n            continue;\n        }\n\n        const replacePatternAsterisks = rightPattern.match(/\\*/g) || [];\n        if (replacePatternAsterisks.length > asterisks.length) {\n            logger.log(`Warning: the right side of a sourceMapPathOverrides entry must have 0 or 1 asterisks - ${entryStr}}`);\n            continue;\n        }\n\n        // Does it match?\n        const escapedLeftPattern = utils.escapeRegexSpecialChars(leftPattern, '/*');\n        const leftRegexSegment = escapedLeftPattern\n            .replace(/\\*/g, '(.*)')\n            .replace(/\\\\\\\\/g, '/');\n        const leftRegex = new RegExp(`^${leftRegexSegment}$`, 'i');\n        const overridePatternMatches = forwardSlashSourcePath.match(leftRegex);\n        if (!overridePatternMatches)\n            continue;\n\n        // Grab the value of the wildcard from the match above, replace the wildcard in the\n        // replacement pattern, and return the result.\n        const wildcardValue = overridePatternMatches[1];\n        let mappedPath = rightPattern.replace(/\\*/g, wildcardValue);\n        mappedPath = utils.properJoin(mappedPath); // Fix any ..\n        if (isVSClient && leftPattern === 'webpack:///./*' && !utils.existsSync(mappedPath)) {\n            // This is a workaround for a bug in ASP.NET debugging in VisualStudio because the wwwroot is not properly configured\n            const pathFixingASPNETBug = path.join(rightPattern.replace(/\\*/g, path.join('../ClientApp', wildcardValue)));\n            if (utils.existsSync(pathFixingASPNETBug)) {\n                ++aspNetFallbackCount;\n                mappedPath = pathFixingASPNETBug;\n            }\n        }\n\n        logger.log(`SourceMap: mapping ${sourcePath} => ${mappedPath}, via sourceMapPathOverrides entry - ${entryStr}`);\n        return mappedPath;\n    }\n\n    return sourcePath;\n}\n\nexport function resolveMapPath(pathToGenerated: string, mapPath: string, pathMapping: IPathMapping): string {\n    if (!utils.isURL(mapPath)) {\n        if (utils.isURL(pathToGenerated)) {\n            const scriptUrl = url.parse(pathToGenerated);\n            const scriptPath = scriptUrl.pathname;\n            if (!scriptPath) {\n                return null;\n            }\n\n            // runtime script is not on disk, map won't be either, resolve a URL for the map relative to the script\n            // handle c:/ here too\n            const mapUrlPathSegment = utils.isAbsolute(mapPath) ?\n                mapPath :\n                path.posix.join(path.dirname(scriptPath), mapPath);\n            mapPath = `${scriptUrl.protocol}//${scriptUrl.host}${mapUrlPathSegment}`;\n        } else if (utils.isAbsolute(mapPath)) {\n            mapPath = chromeUtils.applyPathMappingsToTargetUrlPath(mapPath, pathMapping) || mapPath;\n        } else if (path.isAbsolute(pathToGenerated)) {\n            // mapPath needs to be resolved to an absolute path or a URL\n            // runtime script is on disk, so map should be too\n            mapPath = resolveRelativeToFile(pathToGenerated, mapPath);\n        }\n    }\n\n    return mapPath;\n}\n\nexport function getFullSourceEntry(sourceRoot: string | undefined, sourcePath: string): string {\n    if (!sourceRoot) {\n        return sourcePath;\n    }\n\n    if (!sourceRoot.endsWith('/')) {\n        sourceRoot += '/';\n    }\n\n    return sourceRoot + sourcePath;\n}\n"],"sourceRoot":"../.."}