{"version":3,"sources":["../src/chrome/breakpoints.ts"],"names":[],"mappings":"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","file":"breakpoints.js","sourceRoot":"../..","sourcesContent":["/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\n\nimport { DebugProtocol } from 'vscode-debugprotocol';\nimport { BreakpointEvent, logger } from 'vscode-debugadapter';\nimport { ISetBreakpointsArgs, ISetBreakpointsResponseBody, ISetBreakpointResult } from '../debugAdapterInterfaces';\nimport * as ChromeUtils from './chromeUtils';\nimport { Protocol as Crdp } from 'devtools-protocol';\nimport { ReasonType } from './stoppedEvent';\nimport { InternalSourceBreakpoint } from './internalSourceBreakpoint';\nimport { ScriptContainer } from './scripts';\nimport { ChromeDebugAdapter } from '..';\nimport { IPendingBreakpoint, BreakpointSetResult } from './chromeDebugAdapter';\n\nimport * as utils from '../utils';\nimport * as path from 'path';\nimport * as nls from 'vscode-nls';\nimport { ChromeConnection } from './chromeConnection';\nlet localize = nls.loadMessageBundle();\n\nexport interface IHitConditionBreakpoint {\n    numHits: number;\n    shouldPause: (numHits: number) => boolean;\n}\n\n/**\n * Encapsulates all the logic surrounding breakpoints (e.g. set, unset, hit count breakpoints, etc.)\n */\nexport class Breakpoints {\n\n    private static SET_BREAKPOINTS_TIMEOUT = 5000;\n\n    private static HITCONDITION_MATCHER = /^(>|>=|=|<|<=|%)?\\s*([0-9]+)$/;\n\n    private _breakpointIdHandles: utils.ReverseHandles<Crdp.Debugger.BreakpointId>;\n    private _nextUnboundBreakpointId = 0;\n    private _pendingBreakpointsByUrl: Map<string, IPendingBreakpoint>;\n    private _hitConditionBreakpointsById: Map<Crdp.Debugger.BreakpointId, IHitConditionBreakpoint>;\n\n    // when working with _committedBreakpointsByUrl, we want to keep the url keys canonicalized for consistency\n    // use methods getValueFromCommittedBreakpointsByUrl and setValueForCommittedBreakpointsByUrl\n    private _committedBreakpointsByUrl = new Map<string, ISetBreakpointResult[]>();\n    private _setBreakpointsRequestQ: Promise<any> = Promise.resolve();\n    public get breakpointsQueueDrained(): Promise<void> {\n        return this._setBreakpointsRequestQ;\n    }\n    public get committedBreakpointsByUrl(): Map<string, ISetBreakpointResult[]> {\n        return this._committedBreakpointsByUrl;\n    }\n\n    private getValueFromCommittedBreakpointsByUrl(url: string): ISetBreakpointResult[] {\n        let canonicalizedUrl = utils.canonicalizeUrl(url);\n        return this._committedBreakpointsByUrl.get(canonicalizedUrl);\n    }\n\n    private setValueForCommittedBreakpointsByUrl(url: string, value: ISetBreakpointResult[]): void {\n        let canonicalizedUrl = utils.canonicalizeUrl(url);\n        this._committedBreakpointsByUrl.set(canonicalizedUrl, value);\n    }\n\n    private get chrome() { return this._chromeConnection.api; }\n\n    constructor(\n        private readonly adapter: ChromeDebugAdapter,\n        private readonly _chromeConnection: ChromeConnection,\n    ) {\n\n        this._breakpointIdHandles = new utils.ReverseHandles<Crdp.Debugger.BreakpointId>();\n        this._pendingBreakpointsByUrl = new Map<string, IPendingBreakpoint>();\n        this._hitConditionBreakpointsById = new Map<Crdp.Debugger.BreakpointId, IHitConditionBreakpoint>();\n    }\n\n    reset() {\n        this._committedBreakpointsByUrl = new Map<string, ISetBreakpointResult[]>();\n        this._setBreakpointsRequestQ = Promise.resolve();\n    }\n\n    /**\n     * Using the request object from the DAP, set all breakpoints on the target\n     * @param args The setBreakpointRequest arguments from the DAP client\n     * @param scripts The script container associated with this instance of the adapter\n     * @param requestSeq The request sequence number from the DAP\n     * @param ids IDs passed in for previously unverified breakpoints\n     */\n    public setBreakpoints(args: ISetBreakpointsArgs, scripts: ScriptContainer, requestSeq: number, ids?: number[]): Promise<ISetBreakpointsResponseBody> {\n\n        if (args.source.path) {\n            args.source.path = this.adapter.displayPathToRealPath(args.source.path);\n            args.source.path = utils.canonicalizeUrl(args.source.path);\n        }\n\n        return this.validateBreakpointsPath(args)\n            .then(() => {\n                // Deep copy the args that we are going to modify, and keep the original values in originalArgs\n                const originalArgs = args;\n                args = JSON.parse(JSON.stringify(args));\n                args = this.adapter.lineColTransformer.setBreakpoints(args);\n                const sourceMapTransformerResponse = this.adapter.sourceMapTransformer.setBreakpoints(args, requestSeq, ids);\n                if (sourceMapTransformerResponse && sourceMapTransformerResponse.args) {\n                    args = sourceMapTransformerResponse.args;\n                }\n                if (sourceMapTransformerResponse && sourceMapTransformerResponse.ids) {\n                    ids = sourceMapTransformerResponse.ids;\n                }\n                args.source = this.adapter.pathTransformer.setBreakpoints(args.source);\n\n                // Get the target url of the script\n                let targetScriptUrl: string;\n                if (args.source.sourceReference) {\n                    const handle = scripts.getSource(args.source.sourceReference);\n                    if ((!handle || !handle.scriptId) && args.source.path) {\n                        // A sourcemapped script with inline sources won't have a scriptId here, but the\n                        // source.path has been fixed.\n                        targetScriptUrl = args.source.path;\n                    } else {\n                        const targetScript = scripts.getScriptById(handle.scriptId);\n                        if (targetScript) {\n                            targetScriptUrl = targetScript.url;\n                        }\n                    }\n                } else if (args.source.path) {\n                    targetScriptUrl = args.source.path;\n                }\n\n                if (targetScriptUrl) {\n                    // DebugProtocol sends all current breakpoints for the script. Clear all breakpoints for the script then add all of them\n                    const internalBPs = args.breakpoints.map(bp => new InternalSourceBreakpoint(bp));\n                    const setBreakpointsPFailOnError = this._setBreakpointsRequestQ\n                        .then(() => this.clearAllBreakpoints(targetScriptUrl))\n                        .then(() => this.addBreakpoints(targetScriptUrl, internalBPs, scripts))\n                        .then(responses => ({ breakpoints: this.targetBreakpointResponsesToBreakpointSetResults(targetScriptUrl, responses, internalBPs, ids) }));\n\n                    const setBreakpointsPTimeout = utils.promiseTimeout(setBreakpointsPFailOnError, Breakpoints.SET_BREAKPOINTS_TIMEOUT, localize('setBPTimedOut', 'Set breakpoints request timed out'));\n\n                    // Do just one setBreakpointsRequest at a time to avoid interleaving breakpoint removed/breakpoint added requests to Crdp, which causes issues.\n                    // Swallow errors in the promise queue chain so it doesn't get blocked, but return the failing promise for error handling.\n                    this._setBreakpointsRequestQ = setBreakpointsPTimeout.catch(e => {\n                        // Log the timeout, but any other error will be logged elsewhere\n                        if (e.message && e.message.indexOf('timed out') >= 0) {\n                            logger.error(e.stack);\n                        }\n                    });\n\n                    // Return the setBP request, no matter how long it takes. It may take awhile in Node 7.5 - 7.7, see https://github.com/nodejs/node/issues/11589\n                    return setBreakpointsPFailOnError.then(setBpResultBody => {\n                        const body = { breakpoints: setBpResultBody.breakpoints.map(setBpResult => setBpResult.breakpoint) };\n                        if (body.breakpoints.every(bp => !bp.verified)) {\n                            // We need to send the original args to avoid adjusting the line and column numbers twice here\n                            return this.unverifiedBpResponseForBreakpoints(originalArgs, requestSeq, targetScriptUrl, body.breakpoints, localize('bp.fail.unbound', 'Breakpoint set but not yet bound'));\n                        }\n                        body.breakpoints = this.adapter.sourceMapTransformer.setBreakpointsResponse(body.breakpoints, true, requestSeq) || body.breakpoints;\n                        this.adapter.lineColTransformer.setBreakpointsResponse(body);\n                        return body;\n                    });\n                } else {\n                    return Promise.resolve(this.unverifiedBpResponse(args, requestSeq, undefined, localize('bp.fail.noscript', \"Can't find script for breakpoint request\")));\n                }\n            },\n            e => this.unverifiedBpResponse(args, requestSeq, undefined, e.message));\n    }\n\n    protected validateBreakpointsPath(args: ISetBreakpointsArgs): Promise<void> {\n        if (!args.source.path || args.source.sourceReference) return Promise.resolve();\n\n        // When break on load is active, we don't need to validate the path, so return\n        if (this.adapter.breakOnLoadActive) {\n            return Promise.resolve();\n        }\n\n        return this.adapter.sourceMapTransformer.getGeneratedPathFromAuthoredPath(args.source.path).then<void>(mappedPath => {\n\n            if (!mappedPath) {\n                return utils.errP(localize('validateBP.sourcemapFail', 'Breakpoint ignored because generated code not found (source map problem?).'));\n            }\n\n            const targetPath = this.adapter.pathTransformer.getTargetPathFromClientPath(mappedPath);\n            if (!targetPath) {\n                return utils.errP(localize('validateBP.notFound', 'Breakpoint ignored because target path not found'));\n            }\n\n            return undefined;\n        });\n    }\n\n    /**\n     * Makes the actual call to either Debugger.setBreakpoint or Debugger.setBreakpointByUrl, and returns the response.\n     * Responses from setBreakpointByUrl are transformed to look like the response from setBreakpoint, so they can be\n     * handled the same.\n     */\n    protected async addBreakpoints(url: string, breakpoints: InternalSourceBreakpoint[], scripts: ScriptContainer) {\n        let responsePs: Promise<ISetBreakpointResult>[];\n        if (ChromeUtils.isEvalScript(url)) {\n            // eval script with no real url - use debugger_setBreakpoint\n            const scriptId: Crdp.Runtime.ScriptId = utils.lstrip(url, ChromeUtils.EVAL_NAME_PREFIX);\n            responsePs = breakpoints.map(({ line, column = 0, condition }) => this.chrome.Debugger.setBreakpoint({ location: { scriptId, lineNumber: line, columnNumber: column }, condition }));\n        } else {\n            // script that has a url - use debugger_setBreakpointByUrl so that Chrome will rebind the breakpoint immediately\n            // after refreshing the page. This is the only way to allow hitting breakpoints in code that runs immediately when\n            // the page loads.\n            const script = scripts.getScriptByUrl(url);\n\n            // If script has been parsed, script object won't be undefined and we would have the mapping file on the disk and we can directly set breakpoint using that\n            if (!this.adapter.breakOnLoadActive || script) {\n                const urlRegex = utils.pathToRegex(url);\n                responsePs = breakpoints.map(({ line, column = 0, condition }) => {\n                    return this.addOneBreakpointByUrl(script && script.scriptId, urlRegex, line, column, condition);\n                });\n            } else { // Else if script hasn't been parsed and break on load is active, we need to do extra processing\n                if (this.adapter.breakOnLoadActive) {\n                    return await this.adapter.breakOnLoadHelper.handleAddBreakpoints(url, breakpoints);\n                }\n            }\n        }\n\n        // Join all setBreakpoint requests to a single promise\n        return Promise.all(responsePs);\n    }\n\n    /**\n     * Adds a single breakpoint in the target using the url for the script\n     * @param scriptId the chrome-devtools script id for the script on which we want to add a breakpoint\n     * @param urlRegex The regular expression string which will be used to find the correct url on which to set the breakpoint\n     * @param lineNumber Line number of the breakpoint\n     * @param columnNumber Column number of the breakpoint\n     * @param condition The (optional) breakpoint condition\n     */\n    async addOneBreakpointByUrl(scriptId: Crdp.Runtime.ScriptId | undefined, urlRegex: string, lineNumber: number, columnNumber: number, condition: string): Promise<ISetBreakpointResult> {\n        let bpLocation = { lineNumber, columnNumber };\n        if (this.adapter.columnBreakpointsEnabled && scriptId) { // scriptId undefined when script not yet loaded, can't fix up column BP :(\n            try {\n                const possibleBpResponse = await this.chrome.Debugger.getPossibleBreakpoints({\n                    start: { scriptId, lineNumber, columnNumber: 0 },\n                    end: { scriptId, lineNumber: lineNumber + 1, columnNumber: 0 },\n                    restrictToFunction: false });\n                if (possibleBpResponse.locations.length) {\n                    const selectedLocation = ChromeUtils.selectBreakpointLocation(lineNumber, columnNumber, possibleBpResponse.locations);\n                    bpLocation = { lineNumber: selectedLocation.lineNumber, columnNumber: selectedLocation.columnNumber || 0 };\n                }\n            } catch (e) {\n                // getPossibleBPs not supported\n            }\n        }\n\n        let result;\n        try {\n            result = await this.chrome.Debugger.setBreakpointByUrl({ urlRegex, lineNumber: bpLocation.lineNumber, columnNumber: bpLocation.columnNumber, condition });\n        } catch (e) {\n            if (e.message === 'Breakpoint at specified location already exists.') {\n                return {\n                    actualLocation: { lineNumber: bpLocation.lineNumber, columnNumber: bpLocation.columnNumber, scriptId }\n                };\n            } else {\n                throw e;\n            }\n        }\n\n        // Now convert the response to a SetBreakpointResponse so both response types can be handled the same\n        const locations = result.locations;\n        return <Crdp.Debugger.SetBreakpointResponse>{\n            breakpointId: result.breakpointId,\n            actualLocation: locations[0] && {\n                lineNumber: locations[0].lineNumber,\n                columnNumber: locations[0].columnNumber,\n                scriptId\n            }\n        };\n    }\n\n    /**\n     * Using the request object from the DAP, set all breakpoints on the target\n     * @param args The setBreakpointRequest arguments from the DAP client\n     * @param scripts The script container associated with this instance of the adapter\n     * @param requestSeq The request sequence number from the DAP\n     * @param ids IDs passed in for previously unverified breakpoints\n     */\n    public async getBreakpointsLocations(args: DebugProtocol.BreakpointLocationsArguments, scripts: ScriptContainer, requestSeq: number): Promise<DebugProtocol.BreakpointLocationsResponse['body']> {\n\n        if (args.source.path) {\n            args.source.path = this.adapter.displayPathToRealPath(args.source.path);\n            args.source.path = utils.canonicalizeUrl(args.source.path);\n        }\n\n        try {\n            await this.validateBreakpointsPath(args);\n        } catch (e) {\n            logger.log('breakpointsLocations failed: ' + e.message);\n            return { breakpoints: [] };\n        }\n\n        // Deep copy the args that we are going to modify, and keep the original values in originalArgs\n        args = JSON.parse(JSON.stringify(args));\n        args.endLine = this.adapter.lineColTransformer.convertClientLineToDebugger(typeof args.endLine === 'number' ? args.endLine : args.line + 1);\n        args.endColumn = this.adapter.lineColTransformer.convertClientLineToDebugger(args.endColumn || 1);\n        args.line = this.adapter.lineColTransformer.convertClientLineToDebugger(args.line);\n        args.column = this.adapter.lineColTransformer.convertClientColumnToDebugger(args.column || 1);\n\n        if (args.source.path) {\n            const source1 = JSON.parse(JSON.stringify(args.source));\n            const startArgs = this.adapter.sourceMapTransformer.setBreakpoints({ breakpoints: [{ line: args.line, column: args.column }], source: source1 }, requestSeq);\n            args.line = startArgs.args.breakpoints[0].line;\n            args.column = startArgs.args.breakpoints[0].column;\n\n            const endArgs = this.adapter.sourceMapTransformer.setBreakpoints({ breakpoints: [{ line: args.endLine, column: args.endColumn }], source: args.source }, requestSeq);\n            args.endLine = endArgs.args.breakpoints[0].line;\n            args.endColumn = endArgs.args.breakpoints[0].column;\n        }\n\n        args.source = this.adapter.pathTransformer.setBreakpoints(args.source);\n\n        // Get the target url of the script\n        let targetScriptUrl: string;\n        if (args.source.sourceReference) {\n            const handle = scripts.getSource(args.source.sourceReference);\n            if ((!handle || !handle.scriptId) && args.source.path) {\n                // A sourcemapped script with inline sources won't have a scriptId here, but the\n                // source.path has been fixed.\n                targetScriptUrl = args.source.path;\n            } else {\n                const targetScript = scripts.getScriptById(handle.scriptId);\n                if (targetScript) {\n                    targetScriptUrl = targetScript.url;\n                }\n            }\n        } else if (args.source.path) {\n            targetScriptUrl = args.source.path;\n        }\n\n        if (targetScriptUrl) {\n            const script = scripts.getScriptByUrl(targetScriptUrl);\n            if (script) {\n                const end = typeof args.endLine === 'number' ?\n                    { scriptId: script.scriptId, lineNumber: args.endLine, columnNumber: args.endColumn || 0 } :\n                    { scriptId: script.scriptId, lineNumber: args.line + 1, columnNumber: 0 };\n\n                const possibleBpResponse = await this.chrome.Debugger.getPossibleBreakpoints({\n                    start: { scriptId: script.scriptId, lineNumber: args.line, columnNumber: args.column || 0 },\n                    end,\n                    restrictToFunction: false\n                });\n                if (possibleBpResponse.locations) {\n                    let breakpoints = possibleBpResponse.locations.map(loc => {\n                        return <DebugProtocol.Breakpoint>{\n                            line: loc.lineNumber,\n                            column: loc.columnNumber\n                        };\n                    });\n                    breakpoints = this.adapter.sourceMapTransformer.setBreakpointsResponse(breakpoints, false, requestSeq);\n                    const response = { breakpoints };\n                    this.adapter.lineColTransformer.setBreakpointsResponse(response);\n                    return response as DebugProtocol.BreakpointLocationsResponse['body'];\n                } else {\n                    return { breakpoints: [] };\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Transform breakpoint responses from the chrome-devtools target to the DAP response\n     * @param url The URL of the script for which we are translating breakpoint responses\n     * @param responses The setBreakpoint responses from the chrome-devtools target\n     * @param requestBps The list of requested breakpoints pending a response\n     * @param ids IDs passed in for previously unverified BPs\n     */\n    private targetBreakpointResponsesToBreakpointSetResults(url: string, responses: ISetBreakpointResult[], requestBps: InternalSourceBreakpoint[], ids?: number[]): BreakpointSetResult[] {\n        // Don't cache errored responses\n        const committedBps = responses\n            .filter(response => response && response.breakpointId);\n\n        // Cache successfully set breakpoint ids from chrome in committedBreakpoints set\n        this.setValueForCommittedBreakpointsByUrl(url, committedBps);\n\n        // Map committed breakpoints to DebugProtocol response breakpoints\n        return responses\n            .map((response, i) => {\n                // The output list needs to be the same length as the input list, so map errors to\n                // unverified breakpoints.\n                if (!response) {\n                    return {\n                        isSet: false,\n                        breakpoint: <DebugProtocol.Breakpoint>{\n                            verified: false\n                        }\n                    };\n                }\n\n                // response.breakpointId is undefined when no target BP is backing this BP, e.g. it's at the same location\n                // as another BP\n                const responseBpId = response.breakpointId || this.generateNextUnboundBreakpointId();\n\n                let bpId: number;\n                if (ids && ids[i]) {\n                    // IDs passed in for previously unverified BPs\n                    bpId = ids[i];\n                    this._breakpointIdHandles.set(bpId, responseBpId);\n                } else {\n                    bpId = this._breakpointIdHandles.lookup(responseBpId) ||\n                        this._breakpointIdHandles.create(responseBpId);\n                }\n\n                if (!response.actualLocation) {\n                    // If we don't have an actualLocation nor a breakpointId this is a pseudo-breakpoint because we are using break-on-load\n                    // so we mark the breakpoint as not set, so i'll be set after we load the actual script that has the breakpoint\n                    return {\n                        isSet: response.breakpointId !== undefined,\n                            breakpoint: <DebugProtocol.Breakpoint>{\n                                id: bpId,\n                                verified: false\n                        }\n                    };\n                }\n\n                const thisBpRequest = requestBps[i];\n                if (thisBpRequest.hitCondition) {\n                    if (!this.addHitConditionBreakpoint(thisBpRequest, response)) {\n                        return  {\n                            isSet: true,\n                            breakpoint: <DebugProtocol.Breakpoint>{\n                                id: bpId,\n                                message: localize('invalidHitCondition', 'Invalid hit condition: {0}', thisBpRequest.hitCondition),\n                                verified: false\n                            }\n                        };\n                    }\n                }\n\n                return {\n                    isSet: true,\n                    breakpoint: <DebugProtocol.Breakpoint>{\n                        id: bpId,\n                        verified: true,\n                        line: response.actualLocation.lineNumber,\n                        column: response.actualLocation.columnNumber\n                    }\n                };\n            });\n    }\n\n    private addHitConditionBreakpoint(requestBp: InternalSourceBreakpoint, response: ISetBreakpointResult): boolean {\n        const result = Breakpoints.HITCONDITION_MATCHER.exec(requestBp.hitCondition.trim());\n        if (result && result.length >= 3) {\n            let op = result[1] || '>=';\n            if (op === '=') op = '==';\n            const value = result[2];\n            const expr = op === '%'\n                ? `return (numHits % ${value}) === 0;`\n                : `return numHits ${op} ${value};`;\n\n            // eval safe because of the regex, and this is only a string that the current user will type in\n            /* tslint:disable:no-function-constructor-with-string-args */\n            const shouldPause: (numHits: number) => boolean = <any>new Function('numHits', expr);\n            /* tslint:enable:no-function-constructor-with-string-args */\n            this._hitConditionBreakpointsById.set(response.breakpointId, { numHits: 0, shouldPause });\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private clearAllBreakpoints(url: string): Promise<void> {\n        // We want to canonicalize this url because this._committedBreakpointsByUrl keeps url keys in canonicalized form\n        url = utils.canonicalizeUrl(url);\n        if (!this._committedBreakpointsByUrl.has(url)) {\n            return Promise.resolve();\n        }\n\n        // Remove breakpoints one at a time. Seems like it would be ok to send the removes all at once,\n        // but there is a chrome bug where when removing 5+ or so breakpoints at once, it gets into a weird\n        // state where later adds on the same line will fail with 'breakpoint already exists' even though it\n        // does not break there.\n        return this._committedBreakpointsByUrl.get(url).reduce((p, bp) => {\n            return p.then(() => this.chrome.Debugger.removeBreakpoint({ breakpointId: bp.breakpointId })).then(() => { });\n        }, Promise.resolve()).then(() => {\n            this._committedBreakpointsByUrl.delete(url);\n        });\n    }\n\n    public onBreakpointResolved(params: Crdp.Debugger.BreakpointResolvedEvent, scripts: ScriptContainer): void {\n        const script = scripts.getScriptById(params.location.scriptId);\n        const breakpointId = this._breakpointIdHandles.lookup(params.breakpointId);\n        if (!script || !breakpointId) {\n            // Breakpoint resolved for a script we don't know about or a breakpoint we don't know about\n            return;\n        }\n\n        // If the breakpoint resolved is a stopOnEntry breakpoint, we just return since we don't need to send it to client\n        if (this.adapter.breakOnLoadActive && this.adapter.breakOnLoadHelper.stopOnEntryBreakpointIdToRequestedFileName.has(params.breakpointId)) {\n            return;\n        }\n\n        // committed breakpoints (this._committedBreakpointsByUrl) should always have url keys in canonicalized form\n        const committedBps = this.getValueFromCommittedBreakpointsByUrl(script.url) || [];\n\n        if (!committedBps.find(committedBp => committedBp.breakpointId === params.breakpointId)) {\n            committedBps.push({breakpointId: params.breakpointId, actualLocation: params.location});\n        }\n        this.setValueForCommittedBreakpointsByUrl(script.url, committedBps);\n\n        const bp = <DebugProtocol.Breakpoint>{\n            id: breakpointId,\n            verified: true,\n            line: params.location.lineNumber,\n            column: params.location.columnNumber\n        };\n\n        // need to canonicalize this path because the following maps use paths canonicalized\n        const scriptPath = utils.canonicalizeUrl(this.adapter.pathTransformer.breakpointResolved(bp, script.url));\n\n        if (this._pendingBreakpointsByUrl.has(scriptPath)) {\n            // If we set these BPs before the script was loaded, remove from the pending list\n            this._pendingBreakpointsByUrl.delete(scriptPath);\n        }\n        this.adapter.sourceMapTransformer.breakpointResolved(bp, scriptPath);\n        this.adapter.lineColTransformer.breakpointResolved(bp);\n        this.adapter.session.sendEvent(new BreakpointEvent('changed', bp));\n    }\n\n    private generateNextUnboundBreakpointId(): string {\n        const unboundBreakpointUniquePrefix = '__::[vscode_chrome_debug_adapter_unbound_breakpoint]::';\n        return `${unboundBreakpointUniquePrefix}${this._nextUnboundBreakpointId++}`;\n    }\n\n    private unverifiedBpResponse(args: ISetBreakpointsArgs, requestSeq: number, targetScriptUrl: string, message?: string): ISetBreakpointsResponseBody {\n        const breakpoints = args.breakpoints.map(bp => {\n            return <DebugProtocol.Breakpoint>{\n                verified: false,\n                line: bp.line,\n                column: bp.column,\n                message,\n                id: this._breakpointIdHandles.create(this.generateNextUnboundBreakpointId())\n            };\n        });\n\n        return this.unverifiedBpResponseForBreakpoints(args, requestSeq, targetScriptUrl, breakpoints, message);\n    }\n\n    private unverifiedBpResponseForBreakpoints(args: ISetBreakpointsArgs, requestSeq: number, targetScriptUrl: string, breakpoints: DebugProtocol.Breakpoint[], defaultMessage?: string): ISetBreakpointsResponseBody {\n        breakpoints.forEach(bp => {\n            if (!bp.message) {\n                bp.message = defaultMessage;\n            }\n        });\n\n        if (args.source.path) {\n            const ids = breakpoints.map(bp => bp.id);\n\n            // setWithPath: record whether we attempted to set the breakpoint, and if so, with which path.\n            // We can use this to tell when the script is loaded whether we guessed correctly, and predict whether the BP will bind.\n            this._pendingBreakpointsByUrl.set(\n                utils.canonicalizeUrl(args.source.path),\n                { args, ids, requestSeq, setWithPath: this.adapter.breakOnLoadActive ? '' : targetScriptUrl }); // Breakpoints need to be re-set when break-on-load is enabled\n        }\n\n        return { breakpoints };\n    }\n\n    public async handleScriptParsed(script: Crdp.Debugger.ScriptParsedEvent, scripts: ScriptContainer, mappedUrl: string, sources: string[]) {\n        if (sources) {\n            const filteredSources = sources.filter(source => source !== mappedUrl); // Tools like babel-register will produce sources with the same path as the generated script\n            for (const filteredSource of filteredSources) {\n                await this.resolvePendingBPs(filteredSource, scripts);\n            }\n        }\n\n        if (utils.canonicalizeUrl(script.url) === mappedUrl && this._pendingBreakpointsByUrl.has(mappedUrl) && utils.canonicalizeUrl(this._pendingBreakpointsByUrl.get(mappedUrl).setWithPath) === utils.canonicalizeUrl(mappedUrl)) {\n            // If the pathTransformer had no effect, and we attempted to set the BPs with that path earlier, then assume that they are about\n            // to be resolved in this loaded script, and remove the pendingBP.\n            this._pendingBreakpointsByUrl.delete(mappedUrl);\n        } else {\n            await this.resolvePendingBPs(mappedUrl, scripts);\n        }\n    }\n\n    public async resolvePendingBPs (source: string, scripts: ScriptContainer) {\n        source = source && utils.canonicalizeUrl(source);\n        const pendingBP = this._pendingBreakpointsByUrl.get(source);\n        if (pendingBP && (!pendingBP.setWithPath || utils.canonicalizeUrl(pendingBP.setWithPath) === source)) {\n            logger.log(`OnScriptParsed.resolvePendingBPs: Resolving pending breakpoints: ${JSON.stringify(pendingBP)}`);\n            await this.resolvePendingBreakpoint(pendingBP, scripts);\n            this._pendingBreakpointsByUrl.delete(source);\n        } else if (source) {\n            const sourceFileName = path.basename(source).toLowerCase();\n            if (Array.from(this._pendingBreakpointsByUrl.keys()).find(key => key.toLowerCase().indexOf(sourceFileName) > -1)) {\n                logger.log(`OnScriptParsed.resolvePendingBPs: The following pending breakpoints won't be resolved: ${JSON.stringify(pendingBP)} pendingBreakpointsByUrl = ${JSON.stringify([...this._pendingBreakpointsByUrl])} source = ${source}`);\n            }\n        }\n    }\n\n    public resolvePendingBreakpoint(pendingBP: IPendingBreakpoint, scripts: ScriptContainer): Promise<void> {\n        return this.setBreakpoints(pendingBP.args, scripts, pendingBP.requestSeq, pendingBP.ids).then(response => {\n            response.breakpoints.forEach((bp, i) => {\n                bp.id = pendingBP.ids[i];\n                this.adapter.session.sendEvent(new BreakpointEvent('changed', bp));\n            });\n        });\n    }\n\n    public handleHitCountBreakpoints(expectingStopReason: ReasonType, hitBreakpoints) {\n        // Did we hit a hit condition breakpoint?\n        for (let hitBp of hitBreakpoints) {\n            if (this._hitConditionBreakpointsById.has(hitBp)) {\n                // Increment the hit count and check whether to pause\n                const hitConditionBp = this._hitConditionBreakpointsById.get(hitBp);\n                hitConditionBp.numHits++;\n                // Only resume if we didn't break for some user action (step, pause button)\n                if (!expectingStopReason && !hitConditionBp.shouldPause(hitConditionBp.numHits)) {\n                    this.chrome.Debugger.resume()\n                        .catch(() => { /* ignore failures */ });\n                    return { didPause: false };\n                }\n            }\n        }\n        return null;\n    }\n\n}\n"]}